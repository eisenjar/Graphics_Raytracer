Part 1

Ray casting - most of this was already taken care of for us.  We needed to transform the rays to world space and compute the direction.

Ray-sphere intersection - we created and solved a quadratic equation for the intersection of a line and a sphere.  If there were two intersections, we chose the closer one.

Ray-square intersection - we computed where the ray intersected the xy plane, and then made sure that it was within the bounds of the unit square.

Phong shading - we used the formulas described in class for ambient, diffuse and specular shading.  The material coefficients were taken from the object properties.

Anti-aliasing - instead of shooting one ray per pixel, we shot four evenly spaced rays through each pixel


Part 2

Secondary reflection with specularities -

Shadows -

Texture Mapping - we saved bitmap images, and used the functions defined in bmp_io to read them.  We then created a mapping function from the object-space coordinates to coordinates in the picture, and used those to pick which pixel of the bitmap to use.  We then overwrote the diffuse material properties of the object with the computed ones.

Ray-Cylinder intersection - we created and solved a quadratic equation for the intersection of a line and a cylinder.  If there were two intersections, we chose the closer one.  We also defined a circle intersection function to handle the circular faces.
